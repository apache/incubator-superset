import celery
from caravel import db, models, app
import json
from sqlalchemy import select, text
from sqlalchemy.sql.expression import TextAsFrom
import pandas as pd
import time

celery_app = celery.Celery(config_source=app.config.get('CELERY_CONFIG'))


def init_query(database_id, sql, user_id):
    milis = int(time.time() * 1000)

    query = models.Query()
    query.user_id = user_id
    query.database_id = database_id
    if app.config.get('SQL_MAX_ROW'):
        query.query_limit = app.config.get('SQL_MAX_ROW')
    query.query_name = str(milis)
    query.query_text = sql
    # TODO(bkyryliuk): run explain query to derive the tables and fill in the
    #                   table_ids
    # TODO(bkyryliuk): check the user permissions
    query.start_time = milis
    query.query_status = models.QueryStatus.IN_PROGRESS
    return query


# def create_table_as(sql, table_name):
#     return "CREATE TABLE %s AS %s".format(sql, table_name)


@celery_app.task
def get_sql_results(database_id, sql, user_id):
    query_session = db.session()
    db_to_query = query_session.query(models.Database).filter_by(
        id=database_id).first()
    if not db_to_query:
        return json.dumps(
            {'msg': "Database with id {0} is missing.".format(database_id)})

    query = init_query(database_id, sql, user_id)
    query_session.add(query)
    query_session.flush()

    query_result, success = get_sql_results_internal(sql, db_to_query)
    query_session.commit()
    # TODO: update the query values

    query.end_time = int(time.time() * 1000)
    if success:
        query.query_status = models.QueryStatus.FINISHED
        # TODO(bkyryliuk): fill in query.tmp_table_name
    else:
        query.query_status = models.QueryStatus.FAILED

    query_session.commit()
    query_session.close()
    # TODO(bkyryliuk): return the tmp table  / query_id
    return query_result


# TODO(bkyryliuk): merge the changes made in the carapal first
#                   before merging this PR.
def get_sql_results_internal(sql, db_to_query):
    """Get the SQL query resulst from the give session and db connection.

    Attributes:
      sql (string): SQL query that will be executed
      session (caravel.db.session()): DB session
      mydb (sqlalchemy.orm.query.Query): source of all SELECT statements
            generated by the ORM
    Returns:
      string: table in the html format.
    """
    try:
        eng = db_to_query.get_sqla_engine()
        if app.config.get('SQL_MAX_ROW'):
            sql = sql.strip().strip(';')
            qry = (
                select('*')
                .select_from(TextAsFrom(text(sql), ['*']).alias('inner_qry'))
                .limit(app.config.get('SQL_MAX_ROW'))
            )
        # if db_to_query.select_as_create_table_as:
        #     sql = sql.strip().strip(';')
        #     # TODO(bkyryliuk): figure out if the query is select query.
        #     sql = create_table_as(sql, int(round(time.time() * 1000)))

        sql = str(qry.compile(eng, compile_kwargs={"literal_binds": True}))
        df = pd.read_sql_query(sql=sql, con=eng)
        # TODO(bkyryliuk): refactore the output to be json instead of html
        data = {
            'columns': [c for c in df.columns],
            'data': df.to_dict(orient='records'),
        }
        return json.dumps(data, allow_nan=False), True
    except Exception as e:
        return json.dumps({'msg': e.message}), False
