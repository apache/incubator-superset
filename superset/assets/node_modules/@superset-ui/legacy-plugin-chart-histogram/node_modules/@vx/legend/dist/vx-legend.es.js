import React from 'react';
import PropTypes from 'prop-types';
import { Group } from '@vx/group';
import cx from 'classnames';

function callOrValue(maybeFn, data) {
  if (typeof maybeFn === 'function') {
    return maybeFn(data);
  }
  return maybeFn;
}

function additionalProps(restProps, data) {
  return Object.keys(restProps).reduce(function (ret, cur) {
    ret[cur] = callOrValue(restProps[cur], data);
    return ret;
  }, {});
}

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

LegendItem.propTypes = {
  flexDirection: PropTypes.string,
  margin: PropTypes.string,
  label: PropTypes.object.isRequired
};

function LegendItem(_ref) {
  var children = _ref.children,
      flexDirection = _ref.flexDirection,
      margin = _ref.margin,
      label = _ref.label,
      restProps = objectWithoutProperties(_ref, ['children', 'flexDirection', 'margin', 'label']);

  return React.createElement(
    'div',
    _extends({
      className: 'vx-legend-item',
      style: {
        display: 'flex',
        alignItems: 'center',
        flexDirection: flexDirection,
        margin: margin
      }
    }, additionalProps(restProps, label)),
    children
  );
}

LegendLabel.propTypes = {
  label: PropTypes.string.isRequired,
  margin: PropTypes.string.isRequired
};

function LegendLabel(_ref) {
  var label = _ref.label,
      margin = _ref.margin,
      align = _ref.align;

  return React.createElement(
    'div',
    {
      className: 'vx-legend-label',
      style: {
        justifyContent: align,
        display: 'flex',
        flex: '1',
        margin: margin
      }
    },
    label
  );
}

function ShapeRect(_ref) {
  var fill = _ref.fill,
      width = _ref.width,
      height = _ref.height,
      style = _ref.style;

  return React.createElement('div', {
    style: _extends({
      width: width,
      height: height,
      background: fill
    }, style)
  });
}

function ShapeCircle(_ref) {
  var fill = _ref.fill,
      width = _ref.width,
      height = _ref.height,
      style = _ref.style;

  if (typeof width === 'string') width = 0;
  if (typeof height === 'string') height = 0;
  var size = Math.max(width, height);
  var radius = size / 2;
  return React.createElement(
    'svg',
    { width: size, height: size },
    React.createElement(
      Group,
      { top: radius, left: radius },
      React.createElement('circle', { r: radius, fill: fill, style: style })
    )
  );
}

function valueOrIdentity(x) {
  if (x && x.value) return x.value;
  return x;
}

function renderShape(_ref) {
  var _ref$shape = _ref.shape,
      shape = _ref$shape === undefined ? 'rect' : _ref$shape,
      _ref$fill = _ref.fill,
      fill = _ref$fill === undefined ? valueOrIdentity : _ref$fill,
      _ref$size = _ref.size,
      size = _ref$size === undefined ? valueOrIdentity : _ref$size,
      width = _ref.width,
      height = _ref.height,
      label = _ref.label,
      _ref$shapeStyle = _ref.shapeStyle,
      shapeStyle = _ref$shapeStyle === undefined ? function (x) {
    return undefined;
  } : _ref$shapeStyle;

  var props = {
    width: width,
    height: height,
    label: label,
    fill: fill(_extends({}, label)),
    size: size(_extends({}, label)),
    style: shapeStyle(_extends({}, label))
  };
  if (typeof shape === 'string') {
    if (shape === 'rect') {
      return React.createElement(ShapeRect, props);
    }
    return React.createElement(ShapeCircle, props);
  }
  if (React.isValidElement(shape)) {
    return React.cloneElement(shape, props);
  }
  return React.createElement(shape, props);
}

function LegendShape(_ref) {
  var _ref$shape = _ref.shape,
      shape = _ref$shape === undefined ? ShapeRect : _ref$shape,
      width = _ref.width,
      height = _ref.height,
      margin = _ref.margin,
      label = _ref.label,
      fill = _ref.fill,
      size = _ref.size,
      shapeStyle = _ref.shapeStyle;

  return React.createElement(
    'div',
    {
      className: 'vx-legend-shape',
      style: {
        display: 'flex',
        width: !!size ? size(_extends({}, label)) : width,
        height: !!size ? size(_extends({}, label)) : height,
        margin: margin
      }
    },
    renderShape({
      shape: shape,
      label: label,
      width: width,
      height: height,
      fill: fill,
      shapeStyle: shapeStyle
    })
  );
}

Legend.propTypes = {
  className: PropTypes.string,
  style: PropTypes.object,
  scale: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  shapeWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  shapeHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  shapeMargin: PropTypes.string,
  labelMargin: PropTypes.string,
  itemMargin: PropTypes.string,
  direction: PropTypes.string,
  itemDirection: PropTypes.string,
  fill: PropTypes.func,
  shape: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),
  labelFormat: PropTypes.func,
  labelTransform: PropTypes.func
};

var defaultStyle = {
  display: 'flex'
};

function Legend(_ref) {
  var className = _ref.className,
      _ref$style = _ref.style,
      style = _ref$style === undefined ? defaultStyle : _ref$style,
      shapeStyle = _ref.shapeStyle,
      scale = _ref.scale,
      shape = _ref.shape,
      domain = _ref.domain,
      _ref$fill = _ref.fill,
      fill = _ref$fill === undefined ? valueOrIdentity : _ref$fill,
      _ref$size = _ref.size,
      size = _ref$size === undefined ? valueOrIdentity : _ref$size,
      _ref$labelFormat = _ref.labelFormat,
      labelFormat = _ref$labelFormat === undefined ? valueOrIdentity : _ref$labelFormat,
      _ref$labelTransform = _ref.labelTransform,
      labelTransform = _ref$labelTransform === undefined ? defaultTransform : _ref$labelTransform,
      _ref$shapeWidth = _ref.shapeWidth,
      shapeWidth = _ref$shapeWidth === undefined ? 15 : _ref$shapeWidth,
      _ref$shapeHeight = _ref.shapeHeight,
      shapeHeight = _ref$shapeHeight === undefined ? 15 : _ref$shapeHeight,
      _ref$shapeMargin = _ref.shapeMargin,
      shapeMargin = _ref$shapeMargin === undefined ? '2px 4px 2px 0' : _ref$shapeMargin,
      _ref$labelAlign = _ref.labelAlign,
      labelAlign = _ref$labelAlign === undefined ? 'left' : _ref$labelAlign,
      _ref$labelMargin = _ref.labelMargin,
      labelMargin = _ref$labelMargin === undefined ? '0 4px' : _ref$labelMargin,
      _ref$itemMargin = _ref.itemMargin,
      itemMargin = _ref$itemMargin === undefined ? '0' : _ref$itemMargin,
      _ref$direction = _ref.direction,
      direction = _ref$direction === undefined ? 'column' : _ref$direction,
      _ref$itemDirection = _ref.itemDirection,
      itemDirection = _ref$itemDirection === undefined ? 'row' : _ref$itemDirection,
      restProps = objectWithoutProperties(_ref, ['className', 'style', 'shapeStyle', 'scale', 'shape', 'domain', 'fill', 'size', 'labelFormat', 'labelTransform', 'shapeWidth', 'shapeHeight', 'shapeMargin', 'labelAlign', 'labelMargin', 'itemMargin', 'direction', 'itemDirection']);

  domain = domain || scale.domain();
  var labels = domain.map(labelTransform({ scale: scale, labelFormat: labelFormat }));
  return React.createElement(
    'div',
    {
      className: cx('vx-legend', className),
      style: _extends({}, style, {
        flexDirection: direction
      })
    },
    labels.map(function (label, i) {
      var text = label.text;

      return React.createElement(
        LegendItem,
        _extends({
          key: 'legend-' + label + '-' + i,
          margin: itemMargin,
          flexDirection: itemDirection,
          label: label
        }, restProps),
        React.createElement(LegendShape, {
          shape: shape,
          height: shapeHeight,
          width: shapeWidth,
          margin: shapeMargin,
          label: label,
          fill: fill,
          size: size,
          shapeStyle: shapeStyle
        }),
        React.createElement(LegendLabel, { label: text, margin: labelMargin, align: labelAlign })
      );
    })
  );
}

function defaultTransform(_ref2) {
  var scale = _ref2.scale,
      labelFormat = _ref2.labelFormat;

  return function (d, i) {
    return {
      datum: d,
      index: i,
      text: '' + labelFormat(d, i),
      value: scale(d)
    };
  };
}

LegendQuantile.propTypes = {
  scale: PropTypes.func.isRequired,
  domain: PropTypes.array,
  labelFormat: PropTypes.func,
  labelTransform: PropTypes.func,
  labelDelimiter: PropTypes.string
};

function LegendQuantile(_ref) {
  var scale = _ref.scale,
      domain = _ref.domain,
      _ref$labelFormat = _ref.labelFormat,
      labelFormat = _ref$labelFormat === undefined ? function (x) {
    return x;
  } : _ref$labelFormat,
      labelTransform = _ref.labelTransform,
      _ref$labelDelimiter = _ref.labelDelimiter,
      labelDelimiter = _ref$labelDelimiter === undefined ? '-' : _ref$labelDelimiter,
      restProps = objectWithoutProperties(_ref, ['scale', 'domain', 'labelFormat', 'labelTransform', 'labelDelimiter']);

  domain = domain || scale.range();
  labelTransform = labelTransform || defaultTransform$1({ labelDelimiter: labelDelimiter });
  return React.createElement(Legend, _extends({
    scale: scale,
    domain: domain,
    labelFormat: labelFormat,
    labelTransform: labelTransform
  }, restProps));
}

function defaultTransform$1(_ref2) {
  var labelDelimiter = _ref2.labelDelimiter;

  return function (_ref3) {
    var scale = _ref3.scale,
        labelFormat = _ref3.labelFormat;

    return function (d, i) {
      var _scale$invertExtent = scale.invertExtent(d),
          _scale$invertExtent2 = slicedToArray(_scale$invertExtent, 2),
          x0 = _scale$invertExtent2[0],
          x1 = _scale$invertExtent2[1];

      return {
        extent: [x0, x1],
        text: labelFormat(x0, i) + ' ' + labelDelimiter + ' ' + labelFormat(x1, i),
        value: scale(x0),
        datum: d,
        index: i
      };
    };
  };
}

LegendLinear.propTypes = {
  scale: PropTypes.func.isRequired,
  domain: PropTypes.array,
  steps: PropTypes.number,
  labelFormat: PropTypes.func,
  labelTransform: PropTypes.func
};

function LegendLinear(_ref) {
  var scale = _ref.scale,
      domain = _ref.domain,
      _ref$steps = _ref.steps,
      steps = _ref$steps === undefined ? 5 : _ref$steps,
      _ref$labelFormat = _ref.labelFormat,
      labelFormat = _ref$labelFormat === undefined ? function (x) {
    return x;
  } : _ref$labelFormat,
      _ref$labelTransform = _ref.labelTransform,
      labelTransform = _ref$labelTransform === undefined ? defaultTransform$2 : _ref$labelTransform,
      restProps = objectWithoutProperties(_ref, ['scale', 'domain', 'steps', 'labelFormat', 'labelTransform']);

  domain = domain || defaultDomain({ steps: steps, scale: scale });
  return React.createElement(Legend, _extends({
    scale: scale,
    domain: domain,
    labelFormat: labelFormat,
    labelTransform: labelTransform
  }, restProps));
}

function defaultDomain(_ref2) {
  var steps = _ref2.steps,
      scale = _ref2.scale;

  var domain = scale.domain();
  var start = domain[0];
  var end = domain[domain.length - 1];
  var step = (end - start) / (steps - 1);
  return new Array(steps).fill(1).reduce(function (acc, cur, i) {
    acc.push(start + i * step);
    return acc;
  }, []);
}

function defaultTransform$2(_ref3) {
  var scale = _ref3.scale,
      labelFormat = _ref3.labelFormat;

  return function (d, i) {
    return {
      text: '' + labelFormat(d, i),
      value: scale(d)
    };
  };
}

LegendOrdinal.propTypes = {
  scale: PropTypes.func.isRequired,
  domain: PropTypes.array,
  labelTransform: PropTypes.func,
  labelFormat: PropTypes.func
};

function LegendOrdinal(_ref) {
  var scale = _ref.scale,
      domain = _ref.domain,
      _ref$labelTransform = _ref.labelTransform,
      labelTransform = _ref$labelTransform === undefined ? defaultTransform$3 : _ref$labelTransform,
      _ref$labelFormat = _ref.labelFormat,
      labelFormat = _ref$labelFormat === undefined ? valueOrIdentity : _ref$labelFormat,
      restProps = objectWithoutProperties(_ref, ['scale', 'domain', 'labelTransform', 'labelFormat']);

  return React.createElement(Legend, _extends({
    scale: scale,
    domain: domain,
    labelFormat: labelFormat,
    labelTransform: labelTransform
  }, restProps));
}

function defaultTransform$3(_ref2) {
  var scale = _ref2.scale,
      labelFormat = _ref2.labelFormat;

  return function (d, i) {
    return {
      datum: d,
      index: i,
      text: '' + labelFormat(d, i),
      value: scale(d)
    };
  };
}

LegendThreshold.propTypes = {
  scale: PropTypes.func.isRequired,
  domain: PropTypes.array,
  labelTransform: PropTypes.func,
  labelFormat: PropTypes.func,
  labelDelimiter: PropTypes.string,
  labelLower: PropTypes.string,
  labelUpper: PropTypes.string
};

function LegendThreshold(_ref) {
  var scale = _ref.scale,
      domain = _ref.domain,
      _ref$labelFormat = _ref.labelFormat,
      labelFormat = _ref$labelFormat === undefined ? function (x) {
    return x;
  } : _ref$labelFormat,
      labelTransform = _ref.labelTransform,
      _ref$labelDelimiter = _ref.labelDelimiter,
      labelDelimiter = _ref$labelDelimiter === undefined ? 'to' : _ref$labelDelimiter,
      _ref$labelLower = _ref.labelLower,
      labelLower = _ref$labelLower === undefined ? 'Less than ' : _ref$labelLower,
      _ref$labelUpper = _ref.labelUpper,
      labelUpper = _ref$labelUpper === undefined ? 'More than ' : _ref$labelUpper,
      restProps = objectWithoutProperties(_ref, ['scale', 'domain', 'labelFormat', 'labelTransform', 'labelDelimiter', 'labelLower', 'labelUpper']);

  domain = domain || scale.range();
  labelTransform = labelTransform || defaultTransform$4({
    labelDelimiter: labelDelimiter,
    labelLower: labelLower,
    labelUpper: labelUpper
  });
  return React.createElement(Legend, _extends({
    scale: scale,
    domain: domain,
    labelFormat: labelFormat,
    labelTransform: labelTransform
  }, restProps));
}

function defaultTransform$4(_ref2) {
  var labelDelimiter = _ref2.labelDelimiter,
      labelLower = _ref2.labelLower,
      labelUpper = _ref2.labelUpper;

  return function (_ref3) {
    var scale = _ref3.scale,
        labelFormat = _ref3.labelFormat;

    function format(labelFormat, value, i) {
      var formattedValue = labelFormat(value, i);
      if (formattedValue === 0) return '0';
      return formattedValue || '';
    }
    return function (d, i) {
      var _scale$invertExtent = scale.invertExtent(d),
          _scale$invertExtent2 = slicedToArray(_scale$invertExtent, 2),
          x0 = _scale$invertExtent2[0],
          x1 = _scale$invertExtent2[1];

      var delimiter = ' ' + labelDelimiter + ' ';
      var value = void 0;
      if (x0 !== 0 && !x0 && (x1 === 0 || !!x1)) {
        // lower threshold
        value = x1 - 1;
        delimiter = labelLower;
      } else if ((x0 === 0 || !!x0) && (x1 === 0 || !!x1)) {
        // threshold step
        value = x0;
      } else if (!x1 && (x0 === 0 || !!x0)) {
        // upper threshold
        value = x0 + scale.domain()[1];
        x1 = x0;
        x0 = undefined;
        delimiter = labelUpper;
      }
      return {
        extent: [x0, x1],
        text: '' + format(labelFormat, x0, i) + delimiter + format(labelFormat, x1, i),
        value: scale(value),
        datum: d,
        index: i
      };
    };
  };
}

function LegendSize(_ref) {
  var scale = _ref.scale,
      domain = _ref.domain,
      _ref$steps = _ref.steps,
      steps = _ref$steps === undefined ? 5 : _ref$steps,
      _ref$labelFormat = _ref.labelFormat,
      labelFormat = _ref$labelFormat === undefined ? function (x) {
    return x;
  } : _ref$labelFormat,
      _ref$labelTransform = _ref.labelTransform,
      labelTransform = _ref$labelTransform === undefined ? defaultTransform$5 : _ref$labelTransform,
      restProps = objectWithoutProperties(_ref, ['scale', 'domain', 'steps', 'labelFormat', 'labelTransform']);

  domain = domain || defaultDomain$1({ steps: steps, scale: scale });
  return React.createElement(Legend, _extends({
    scale: scale,
    domain: domain,
    labelFormat: labelFormat,
    labelTransform: labelTransform
  }, restProps));
}

function defaultDomain$1(_ref2) {
  var steps = _ref2.steps,
      scale = _ref2.scale;

  var domain = scale.domain();
  var start = domain[0];
  var end = domain[domain.length - 1];
  var step = (end - start) / (steps - 1);
  return new Array(steps).fill(1).reduce(function (acc, cur, i) {
    acc.push(start + i * step);
    return acc;
  }, []);
}

function defaultTransform$5(_ref3) {
  var scale = _ref3.scale,
      labelFormat = _ref3.labelFormat;

  return function (d, i) {
    return {
      text: '' + labelFormat(d, i),
      value: scale(d),
      datum: d,
      index: i
    };
  };
}

export { Legend, LegendQuantile, LegendLinear, LegendOrdinal, LegendThreshold, LegendSize };
